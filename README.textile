h1. Listalicious

Semantic listing; a semantic way to build datagrid structures in Rails.

h2. The Story

Ok, so I really liked what came of my navigasmic gem, and it's proved itself useful and flexible.  I'm also working on unifying some aspects of a CMS and decided that datagrids should be unified to some degree so I can simplify the generators, make broad changes if I need to, and have a potentially more efficient way to create them.

So I started this project to do just that.  I quickly learned that datagrids aren't especially easy to make amazing, and there's a lot of things that one might want to do with them... grouping (with a row that creates a separator), sorting, ordering, additional informational rows, footers, ajax pagination, etc. etc. etc.. The list is actually pretty long, and I wrote a lot of those things, but it's nowhere near perfect.  I sort of don't think it's possible with how I've approached it this time around.  Anyhow, I thought I could get something to a point that simplified the datagrid process, and I believe I've succeeded in providing a good start.  I opted out of adding several features for the time being until I need them -- at which point I might have a better understanding of how I could approach it better.  I cover some of my thoughts below in this document.

So, as always, I set up some requirements for what the project should do, and here's what I came up with (a lot of these are standard):

* Should be simple
* Should be easily customizable
* Should handle sorting
* Should handle grouping
* Should handle ordering columns
* Should handle additional informational rows
* Should be pleasant to use
* Should use less code to create than it generates

I wrote a DSL that met those requirements:

<pre>
  <% semantic_list_for @users do |l| %>
    <%= l.head do %>
      <%= l.column 'Name', :sort => 'last_name' %>
      <%= l.column 'Email Address' %>
    <% end %>
    <%= l.columns do |user, index| %>
      <%= l.column "#{user.first_name} #{user.last_name}" %>
      <%= l.column link_to(user.email, "mailto:#{user.email}") %>
      <%= l.controls link_to('edit', edit_user_path(user)) %>
    <% end %>
    <%= l.foot do %>
      <%= l.full_column will_paginate(@users) %>
    <% end %>
  <% end %>
</pre>

I liked this, but could it be reduced further if the use case allowed?  I came up with the following, which simplifies it, but comes with a minor snag.  Note the line that instantiates a new User object.  This is needed if there's no objects in the collection you pass it, because it needs to know about the object while it's building the columns.

<pre>
  <% semantic_list_for @users do |l| %>
    <%= l.columns [:head, :body] do |user, index| %>
      <% user ||= User.new # this DSL requires a user object to be here %>
      <%= l.column user.login, :title => 'Login', :sort => 'login' %>
      <%= l.column user.email, :title => 'Email Address', :sort => 'email' %>
      <%= l.controls link_to('edit', edit_user_path(user)) %>
    <% end %>
  <% end %>
</pre>

Clearly there's some ups and downs here, so I implemented both DSLs and leave it to your discretion to figure out which one is best to use in your case.

Since using builders on previous projects has worked out fairly well, I ventured down that path again.  There's a single builder provided for now, TableBuilder (which inherits from GenericBuilder).  GenericBuilder provides some basic functionality (ordering links for example), and isn't intended to be used as a builder by itself.  And of course, the builders can always be extended or replaced if you need more custom markup.

h2. Installation

The gem is hosted on gemcutter, so *if you haven't already*, add it as a gem source:

<pre>
  sudo gem sources -a http://gemcutter.org/
</pre>

Then install the listalicious gem:

<pre>
  sudo gem install listalicious
</pre>

If you would like to get the default JS and CSS files you can use the generator after installing:

<pre>
  [no javascript or css provided yet]
</pre>

h2. Usage

Listalicious works fine just as a view helper, but it also handles ordering of the lists.  If you plan on using ordering in the lists you'll have to add a bit to the model and controller.  All of the methods are added to the model by using sortable_fields, and the :order option on finders can be generated by using sort_order_from in the controller.

h3. Models

<pre>
  class User < ActiveRecord::Base
    # communicates to Listalicious how a list of this model can be ordered
    sortable_fields :first_name, :last_name, :login, :email, :default => :login
  end
</pre>

h3. Controllers

<pre>
  def index
    @users = User.paginate :page => params[:page], :per_page => 2, :order => User.sort_order_from(params)
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml => @users }
    end
  end
</pre>

h3. Views (I prefer HAML, so no ERB examples, but it should work with ERB fine as well)
  
It's important to note that all the methods take blocks or content strings.  For instance, look at the extra and controls methods in the simple usage example.

It's also important to notice that the controls cell is not being counted in the columns.  This is because I position these absolutely and do a hover event on them.. I'll likely take this out, and make a builder that had that that doesn't effect anyone else.. this is pre-release sort of stuff.

*Simple Usage*

<pre>
  - semantic_list_for @users, :html => {:class => 'list'} do |l|
    = l.columns [:head, :body] do |user, index|
      - user ||= User.new # this method requires a user object
      = l.column user.login, :title => 'Login', :sort => 'login', :width => '20%'
      = l.column user.email, :title => 'Email Address', :sort => 'email'
      = l.extra do
        = "You can add more information about #{user.first_name} here."
      = l.controls link_to('edit', edit_user_path(user))
</pre>
  ...produces...
<pre>
  <table class="list semantic-list" id="user_list">
    <thead>
      <tr class="header">
        <th width="20%"><a class="sort-ascending" href="?user_sort_desc=login">Login</a></th>
        <th><a href="?user_sort_asc=email">Email Address</a></th>
      </tr>
    </thead>
    <tbody>
      <tr class="even">
        <td>jejacks0n</td>
        <td>jeremy@email.com</td>
        <td class="controls"><a href="/users/1/edit">edit</a></td>
      </tr>
      <tr class="even">
        <td colspan="2">You can add more information about Jeremy here.</td>
      </tr>
      <tr class="odd">
        <td>user1</td>
        <td>user1@email.com</td>
        <td class="controls"><a href="/users/2/edit">edit</a></td>
      </tr>
      <tr class="odd">
        <td colspan="2">You can add more information about User here.</td>
      </tr>
    </tbody>
  </table>
</pre>

*Extended Usage*

<pre>
  - semantic_list_for @users do |l|
    = l.head do
      = l.column 'Name', :sort => 'last_name', :width => '20%'
      = l.column 'Email Address'
    = l.columns do |user, index|
      = l.column "#{user.first_name} #{user.last_name}"
      = l.column :html => {:class => 'email'} do
        = link_to(user.email, "mailto:#{user.email}")
      = l.controls link_to('edit', edit_protosite_user_path(user))
    = l.foot do
      = l.full_column will_paginate(l.collection)
</pre>
  ...produces...
<pre>
  <table class="semantic-list" id="user_list">
    <thead>
      <tr class="header">
        <th width="20%"><a class="sort-ascending" href="?user_sort_asc=last_name">Name</a></th>
        <th>Email Address</th>
      </tr>
    </thead>
    <tbody>
      <tr class="even">
        <td>Jeremy Jackson</td>
        <td class="email"><a href="mailto:jeremy@factorylabs.com">jeremy@factorylabs.com</a></td>
        <td class="controls"><a href="/protosite/users/1/edit">edit</a></td>
      </tr>
      <tr class="odd">
        <td>User 1</td>
        <td class="email"><a href="mailto:user1@protosite.com">user1@protosite.com</a></td>
        <td class="controls"><a href="/protosite/users/2/edit">edit</a></td>
      </tr>
    </tbody>
    <tfoot>
      <tr>
        <th colspan="2">
          <div class="pagination">[removed for your sanity]</div>
        </th>
      </tr>
    </tfoot>
  </table>
</pre>

*Grouping* -- You can group lists, and this will add extra header rows as separators.  This will include sort links if those were provided as well.

<pre>
  - semantic_list_for @users, :group_by => :login do |l|
</pre>

*Sorting* -- Sorting requires javascript.  It's part of the javascript code that comes with Listalicious and requires Prototype.js.  If you want to add sorting to the list, just provide a url for a sort action and it will put that into the HTML5 data-sorturl attribute.  You can use your own javascript if you would like.

<pre>
  - semantic_list_for @users, :sort_url => { :action => 'sort' } do |l|
</pre>

*Additional JS Functionality* -- There a few functions that are javascript specific.  You can add any additional functionality this way as well, since we're using unobtrusive JS to get the following features accomplished.

You can make the list multi-selectable.  There isn't any pre-bundled functionality to do actions on the selected items, but you can fetch the list of selected items by using JS.

<pre>
  - semantic_list_for @users, :selectable => true do |l|
</pre>

You can make the "extra" information rows expandable.  If you add this, the extra rows won't show unless the row they belong to is highlighted.

<pre>
  - semantic_list_for @users, :expandable => true do |l|
</pre>

h3. UL / OL Datagrids

The nature of doing a UL / OL based datagrid requires a certain level of CSS, and I haven't had time or reason to provide that level yet.  When I finish up this project and include the JS and CSS needed for it (in a generator) I may add a builder for this, but there isn't one currently.

h3. Other

It's important to note that a lot of the functionality of these lists do not play nicely with one another -- I don't believe this is a shortcoming, and consider it more an effort to avoid overkill.  A good example of this is the sortable features.  For example, if you need the extra information and sorting together, you should consider using the :expandable => true option.  Grouping and sorting don't play together nicely for obvious reasons as well.  The javascript handles moving the extra container, in sorting, but doesn't attempt to do it gracefully.  If I do the ListBuilder (UL/OL) to compliment the TableBuilder, it would likely handle these things somewhat better, but I haven't had a need for it yet.

I'm kicking around plans for how to make it more featureful without the annoying conflicts mentioned above.  If you have any thoughts let me know, but I expect my solution will come in breaking up the builders by features.. So, instead of having a single TableBuilder, there would be a SortableTableBuilder, and an InformationalTableBuilder, and a MultiSelectTableBuilder, etc.. not sure how that would play out, but that's what I'm thinking might resolve some of the annoyances mentioned above.

And, as always, you can create your own builder by extending one of the existing ones, or by creating one from scratch.

Then just specify your builder, or do it as a configuration.

<pre>
  semantic_list_for @users, :builder => MyCustomBuilder do
</pre>

<pre>
  Listalicious::SemanticListHelper.builder = MyCustomBuilder
<pre>

h2. Documentation

RDoc documentation _should_ be automatically generated after each commit and made available on the "rdoc.info website":http://rdoc.info/projects/jejacks0n/listalicious.

Documentation is pretty sparse right now.

h2. Compatibility

I'm only testing with the latest Rails 2.4.x stable release, and it should work under Rails 2.3.x as well.  Feel free to add backwards compatibility if you need it.

h2. Project Info

Listalicious is hosted on Github: "http://github.com/jejacks0n/listalicious":http://github.com/jejacks0n/listalicious, and the gem is available on Gemcutter: "http://gemcutter.org/gems/listalicious":http://gemcutter.org/gems/listalicious


Copyright (c) Jeremy Jackson, released under the MIT license.
